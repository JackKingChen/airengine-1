#include "Common.h"
ByteAddressBuffer	voxeloctree		:	register(t0);

cbuffer cbPerMaterial	:	register(b3)
{
	matrix	matViewProjInv;
}

bool	RayCastBoundingBox(float3 vStart,float3 vDir,float3 vMin,float3 vMax,in float fMaxDistance,inout float fOutDistance)

{
	float3	fmin		=	vMin	-	vStart;
	float3	fmax		=	vMax	-	vStart;
	float3	invMinDir	=	fmin	/	vDir;
	float3	invMaxDir	=	fmax	/	vDir;

	fOutDistance		=	10000.0f;

	float3	fNear		=	min(invMinDir,invMaxDir);
	float3	fFar		=	max(invMinDir,invMaxDir);
	float	maxNear		=	max(max(fNear.x,fNear.y),fNear.z);
	float	minFar		=	min(min(fFar.x,fFar.y),fFar.z);
	if(	maxNear	>	minFar	||
		maxNear	>	fMaxDistance	||
		minFar	<	0.0f)
	{
		return	false;
	}
	if(maxNear	<	0.0f)
		maxNear	=	0.0f;
	fOutDistance	=	maxNear;	
	return	true;
};

struct VS_OUTPUT
{
    float4 Position     : SV_POSITION; // vertex position
	float2 UV			: TEXCOORD0;
};

struct	PS_OUTPUT{
	float4	Diff			:	SV_Target0;
};

float4	U32_F32(uint uiColor){
	return	float4(
					((uiColor&0x00ff0000)>>16)/255.0f,
					((uiColor&0x0000ff00)>>8)/255.0f,
					((uiColor&0x000000ff))/255.0f,
					((uiColor&0xff000000)>>24)/255.0f
			);
}

float4 main( VS_OUTPUT Input ):SV_Target0{
	float2 xy	=	Input.UV*float2(2,-2)+float2(-1,1);
	float4	wpos	=	mul(matViewProjInv,float4(xy,1,1));
	wpos/=wpos.w;
	float3 dir	=	normalize(wpos.xyz	-	vCameraPosition.xyz);


	uint uiOffset[10]={
		0,0,0,0,0,
		0,0,0,0,0
	};
	uint uiStack[10]={
		0,0,0,0,0,
		0,0,0,0,0
	};
	float3 vOffset[8]={
		float3(0,0,0),
		float3(0,0,1),
		float3(0,1,0),
		float3(0,1,1),

		float3(1,0,0),
		float3(1,0,1),
		float3(1,1,0),
		float3(1,1,1),
	};
	uint	uiDepth	=	0;
	float3	vHalfSize	=	64.0f;
	float3  vMin		=	float3(-64,-64,-64);
	float	fMaxDis		=	10000;
	float f=0;
	if(!RayCastBoundingBox(vCameraPosition.xyz,dir,vMin,vHalfSize,fMaxDis,f)){
		discard;
	}
	uint	retColor	=	0xffff0000;
	while(true){
		
		for(int i=uiStack[uiDepth];i<8;){
			


			uint addr		=	(uiOffset[uiDepth]+i)*4;
			uint uiChild	=	voxeloctree.Load(addr);
			if(uiChild==0){
				i++;
				continue;
			}

			float3	vNewMin	=	vMin+vOffset[i]*vHalfSize;
			float3	vNewMax	=	vNewMin+vHalfSize;
			
			float fDis	=	100000.0f;
			if(!RayCastBoundingBox(vCameraPosition.xyz,dir,vNewMin,vNewMax,fMaxDis,fDis)){
				i++;
				continue;
			}
			

			if(uiDepth	==	1){
				if(fDis	<	fMaxDis){
					fMaxDis		=	fDis;
					retColor	=	0xffffffff;//uiChild;	
				}	
				
				i++;
				continue;			
			}else{
				uiStack[uiDepth]	=	i+1;
				uiDepth++;
				uiStack[uiDepth]	=	0;
				uiOffset[uiDepth]	=	uiChild;
				vHalfSize	/=	2.0f;
				vMin		=	vNewMin;
				i=0;
				break;
			}
		}
		if(uiDepth==0){
			break;
		}else{
			uiDepth--;
			vHalfSize*=2.0f;
			vMin	-=	vOffset[uiStack[uiDepth]-1]*vHalfSize;
		}
	}
	return U32_F32(retColor);
//	return float4(1,0,0,0);
};