#define	NUMBER_BLOCK_WIDTH	16
#define	NUMBER_THREAD		NUMBER_BLOCK_WIDTH*NUMBER_BLOCK_WIDTH
#define	HALF_NUMBER_THREAD	NUMBER_THREAD/2

cbuffer cbPerCamera : register( b1 )
{
    matrix  ViewProjection;
	float4	vCameraDir;
	float4	vCameraPosition;
	float4	vCameraUp;
	float4	vVP_NearFar;
   
};
cbuffer	cbPerMaterial	: register( b3 )
{
	float4	RTWidthHeight;
	float4x4 matViewProjInv;
	float4x4 matView;
	float4	mouse;
}

struct PointLightInfo{
	float4 Pos_Size;
	float3 Color;
};

Texture2D							DepthTex		:	register(t0);
Texture2D							NormalTex		:	register(t1);
StructuredBuffer<PointLightInfo>	LightBuffer		:	register(t2);
RWTexture2D<float4>					OutLightTex		:	register(u0);

groupshared PointLightInfo	tempLightBuffer[NUMBER_THREAD];
groupshared	int				tempLightCount;
groupshared float	tempDepth[NUMBER_THREAD];
groupshared float4	tempPos[5];
groupshared float	tempAngle;

float4 Vertex3_Plane(float3 v1,float3 v2,float3 v3){
	float3	aux1 = v1 - v2;
	float3	aux2 = v1 - v3;
	float4 plane;
	plane.xyz = (cross((aux1),(aux2)));

	normalize(plane.xyz);

	plane.w = dot((plane.xyz),v1);
	return plane;
}

bool IsOutSide(float4 plane,float4 sphere){
	return (sphere.w < dot(plane.xyz,sphere.xyz));
}

float2 UV_XY(float2 uv){
	return uv*float2(2,-2)+float2(-1,1);
}

[numthreads(NUMBER_BLOCK_WIDTH, NUMBER_BLOCK_WIDTH, 1)]
void	main(
	uint3	Gid		:	SV_GroupID,
	uint3	GTid	:	SV_GroupThreadID,
	uint3	DTid	:	SV_DispatchThreadID)
{
	//Calc Min Max Depth
	uint	GIndex		=	GTid.y*NUMBER_BLOCK_WIDTH+GTid.x;
	float	fDepth		=	DepthTex.Load(DTid.xyz);
	
	float3	N			=	NormalTex.Load(DTid.xyz);
	N=N*2-1;
	N					=	mul((float3x3)matView,N);

	float2	uv			=	((float2)DTid.xy+0.5)/RTWidthHeight.xy;

	float2 mousepos		=	mouse/RTWidthHeight.xy;
	mousepos.y	=	1-mousepos.y;


	uv.y	=	1-uv.y;
	float4	projpos		=	float4(uv*2-1,fDepth,1); 
	projpos				=	mul(matViewProjInv,projpos);
	projpos/=projpos.w;

	tempDepth[GIndex]	=	projpos.z;
	GroupMemoryBarrierWithGroupSync();        
	for(uint i=NUMBER_THREAD/2;i>0;i/=2)
	{
		if(GIndex<i){
			float	left	=	tempDepth[GIndex];
			float	right	=	tempDepth[GIndex	+	i];	
			if(right	<	left){
				tempDepth[GIndex]			=	right;
				tempDepth[GIndex	+	i]	=	left;
			}
		}
		
		else	if(i!=NUMBER_THREAD/2 && GIndex >= NUMBER_THREAD-i){
			int	newGIndex	=	NUMBER_THREAD-GIndex-1;
			float	left	=	tempDepth[newGIndex	-	i];
			float	right	=	tempDepth[newGIndex];	
			if(right	<	left){
				tempDepth[newGIndex	-	i]	=	right;
				tempDepth[newGIndex]		=	left;
			}
		}
		
		GroupMemoryBarrierWithGroupSync();
	}
	float	fNear	=	tempDepth[0];
	float	fFar	=	tempDepth[NUMBER_THREAD-1];//tempDepth[NUMBER_THREAD-1];
	float fLast;
	//uint	DIndex	=	DTid.y*RTWidthHeight.x+DTid.x;
	//InterlockedExchange(OutLightTex[DTid.xy],(fFar-fNear)*0.1,fLast);
	//Calc Quad Vertex Pos
	float4 vQuadProjPos[5]={
		float4(Gid.xy+float2(0.5,0.5),1,1),
		float4(Gid.xy,1,1),
		float4(Gid.xy+float2(1,0),1,1),
		float4(Gid.xy+float2(1,1),1,1),
		float4(Gid.xy+float2(0,1),1,1)
		};
	if(GIndex<5){
		float4 temp		=	vQuadProjPos[GIndex]*float4(NUMBER_BLOCK_WIDTH,NUMBER_BLOCK_WIDTH,1,1);
		temp.xy			=	(temp.xy)/	RTWidthHeight.xy;
		temp.xy			=	UV_XY(temp.xy);
		temp.xy			*=	RTWidthHeight.zw;
//		float4 vTemp	=	mul(matViewProjInv,float4(UV_XY(temp.xy),temp.zw));
//		vTemp/=vTemp.w;
		//normalize(vTemp.xyz);
		tempPos[GIndex]	=	temp;
	}
	tempAngle = 0;
	GroupMemoryBarrierWithGroupSync();
	//Calc Plane Normal Distance
	float3 vCenter = normalize(tempPos[0].xyz);
	if(GIndex==0){
		
		float4 angle;
		angle.x	=	acos(dot(normalize(tempPos[1].xyz),vCenter));//	=	Vertex3_Plane(float3(0,0,0),tempPos[GIndex].xyz,tempPos[nextIndex].xyz);
		angle.y	=	acos(dot(normalize(tempPos[2].xyz),vCenter));
		angle.z	=	acos(dot(normalize(tempPos[3].xyz),vCenter));
		angle.w	=	acos(dot(normalize(tempPos[4].xyz),vCenter));	
		tempAngle	=	max(max(angle.x,angle.y),max(angle.z,angle.w));
	}

	tempLightCount=0;
	//tempLightBuffer[GIndex]	=	LightBuffer[GIndex];
	GroupMemoryBarrierWithGroupSync();
#if 0

	
	float4	mousepos2		=	float4(mousepos.xy*2-1,0,1);
	float4 mouseposprojpos				=	mul(matViewProjInv,mousepos2);
	mouseposprojpos/=mouseposprojpos.w;
	mouseposprojpos.w = 0.1;

	float SphereAngle = atan(mouseposprojpos.w/length(mouseposprojpos.xyz));

	float fColor = 0;
	if(SphereAngle+tempAngle >	acos(dot(normalize(mouseposprojpos.xyz),vCenter))){
		fColor	=	1.0f;
	}	

	InterlockedExchange(OutLightTex[DTid.xy],fColor,fLast);

	
#else
	
	//Intersect Light With Quad Frustum
	if(GIndex < 4){
	uint iIntersectCount	=	0;
	PointLightInfo linfo	=	LightBuffer[GIndex];

	float4 tempvp = mul(matView,float4(linfo.Pos_Size.xyz,1));
	linfo.Pos_Size.xyz	=tempvp.xyz/tempvp.w;
	//linfo.Pos_Size.w	=	8;	

	float zDepth	=	linfo.Pos_Size.z;
	float	fSize	=	linfo.Pos_Size.w;
	float fLightLength	=	length(linfo.Pos_Size.xyz);
	float SphereAngle = asin(fSize/fLightLength);

	if(fSize>fLightLength){
		float3 vNear	=	(vCenter/vCenter.z)*fNear;
		if(distance(vNear,linfo.Pos_Size.xyz)<fSize){
			float oldValue;
			InterlockedAdd(tempLightCount,1,oldValue);
			tempLightBuffer[oldValue]	=	linfo;
		}
	}else{
	
		if(SphereAngle+tempAngle >	acos(dot(normalize(linfo.Pos_Size.xyz),vCenter))){
			//fColor	=	1.0f;
			float3 vNewDir	=	(vCenter/vCenter.z);
			float3 vFustrumCenter = vNewDir*(fFar+fNear)*0.5;
			float fFustrumSize		=	length(vNewDir)*(fFar-fNear)*0.5;
			if(distance(vFustrumCenter,linfo.Pos_Size.xyz)<fFustrumSize+fSize){
			//if(zDepth+fSize > fNear&& zDepth-fSize < fFar){
				float oldValue;
				InterlockedAdd(tempLightCount,1,oldValue);
				tempLightBuffer[oldValue]	=	linfo;
			}
		}	
	}
	}
	GroupMemoryBarrierWithGroupSync();
	//float fColor = tempLightCount;
	//InterlockedExchange(OutLightTex[DTid.xy],fColor*0.01	,fLast);
#endif
	
	float4 Color=0;
	uint uiCount	=	tempLightCount;
	//Shading The Pixel
	for(int i=0;i<uiCount;i++){
		PointLightInfo lightinfo	=	tempLightBuffer[i];
		float3 LDir	=	lightinfo.Pos_Size.xyz-projpos.xyz;
		float3 L	=	normalize(LDir);
		Color	+=	pow((1-length(LDir)/lightinfo.Pos_Size.w),2);//*saturate(dot(L,normalize(N)));//*saturate(1-length(LDir)/lightinfo.Pos_Size.w);
	}

	OutLightTex[DTid.xy]=(float)tempLightCount*0.25f;
	
}